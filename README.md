# Dante API 自訂資料傳輸方案：ConMon 協定與韌體協作需求

## 1. 目的

本文主要說明目前應用程式 (C++ 範例) 如何透過 Dante API 的 ConMon (Control and Monitoring) 協定向 Dante 設備傳送自訂資料。同時，也將指出實現雙向測試和確認所需的關鍵缺失環節，並澄清相關技術概念，以評估此方案在現有硬體平台上的可行性。

## 2. 目前自訂資料傳輸方法

我們目前採用 **ConMon 協定中的「供應商特定訊息 (Vendor-Specific Messages)」** 來傳送自訂資料。

*   **ConMon 協定簡述：** ConMon 是 Dante 設備之間用於控制和監控的通訊協定。它允許設備交換非音訊的控制指令、狀態更新和監控數據。可以將其理解為 Dante 設備之間用於管理目的的「語言」。

*   **供應商特定訊息 (Vendor-Specific Messages)：** ConMon 協定提供了一個標準框架，允許製造商或開發者定義自己的訊息類型和資料格式，以實現標準協定之外的自訂功能。這些訊息透過一個唯一的「供應商 ID (Vendor ID)」來識別，確保不同供應商的自訂訊息不會衝突。

*   **傳輸機制：**
    *   **供應商 ID (Vendor ID)：** 我們在程式碼中定義了一個範例供應商 ID (`vendor_example_id`)，用於標識我們的自訂訊息。在實際應用中，這應該是一個獨特的識別碼。
    *   **指令 ID (Command ID) 與訊息類型 (Message Type)：** 我們定義了自訂的整數 ID (例如 `VENDOR_COMMAND_1`, `VENDOR_MSG_TYPE_1`) 來表示不同的自訂指令或訊息類別。
    *   **酬載 (Payload)：** 實際的自訂資料 (例如字串 `"Hello from C++ ConMon!"`) 被封裝在一個結構體 (`VendorMessagePayload`) 中，作為訊息的酬載部分。
    *   **傳送：** 應用程式使用 Dante API 的 `conmon_client_send_control_message()` 函數，將包含自訂供應商 ID、指令 ID、訊息類型和酬載的訊息發送給目標 Dante 設備。

*   **C++ 範例 (`custom_conmon_example`)：**
    *   我們的 C++ 範例程式碼 (`main.cpp`, `ConMonClient.cpp`, `CustomCommand.h`) 實現了連接 ConMon 服務、發送自訂供應商訊息的功能。
    *   它支援透過命令列參數指定目標設備名稱、指令 ID、訊息類型和資料字串，例如：
        ```bash
        ./custom_conmon_example TX-PC-1 100 200 "Hello from Meiloon"
        ```
    *   程式中也包含了接收 ConMon 訊息的通用回呼 (`onConMonMessage`)，可以捕獲來自設備的供應商特定訊息。

## 3. 雙向測試與確認的缺失環節

目前，應用程式發送自訂 ConMon 控制訊息的行為是「發後不理 (fire-and-forget)」的。這意味著：

*   **單向傳輸：** 應用程式成功呼叫 `sendCustomCommand()` 僅表示訊息已成功提交給 Dante API 庫，並嘗試發送到網路。
*   **缺乏確認：** 應用程式無法直接得知目標設備是否：
    1.  **成功接收**到該訊息。
    2.  **正確解析**了該訊息。
    3.  **執行**了該訊息所指示的動作。
    4.  **發送了任何回覆**來確認接收或執行結果。

**關鍵缺失：韌體對自訂訊息的接收與回覆支援**

要實現應用程式與設備之間可靠雙向通訊和測試確認，**設備的韌體必須被編程以理解並響應這些自訂的 ConMon 供應商特定訊息。**

*   **韌體需求：**
    1.  **監聽自訂供應商 ID：** 設備韌體需要能夠監聽並識別我們應用程式所使用的特定「供應商 ID」。
    2.  **解析自訂訊息：** 韌體需要解析訊息中的「指令 ID」、「訊息類型」和「酬載」，並根據這些資訊執行相應的內部邏輯。
    3.  **發送回覆訊息 (確認機制)：** 這是最重要的一步。韌體在處理完自訂指令後，應發送一個 ConMon 訊息作為回覆，以確認接收和處理狀態。這個回覆可以是：
        *   **標準 ConMon 狀態訊息：** 如果有合適的標準狀態訊息可以表達結果。
        *   **另一個自訂 ConMon 供應商特定訊息：** 這是最靈活的方式，可以包含處理結果、錯誤碼或任何其他相關數據。

**結論：** 除非設備韌體明確支援接收和回覆這些自訂訊息，否則我們無法在應用程式層面確認訊息是否成功傳達並被處理。目前的測試僅能確認應用程式端發送 API 呼叫的成功。

## 4. 相關概念澄清

*   **ConMon (Control and Monitoring) 協定：**
    *   它是 Dante 網路中用於設備控制、狀態監控和配置的通訊協定。
    *   它運行在音訊數據流之外，處理設備名稱、時鐘狀態、路由訂閱、韌體更新等非音訊數據。
    *   我們的自訂資料傳輸方案就是基於 ConMon 協定的擴展能力。

*   **Dante Virtual Soundcard (DVS) 或 Dante Via：**
    *   **DVS：** 是一款軟體，能將標準電腦轉變為一個 Dante 音訊設備。它允許電腦上的音訊應用程式直接與 Dante 網路進行音訊通訊。
    *   **Dante Via：** 是一款軟體，提供更靈活的音訊路由，允許電腦上的應用程式之間以及應用程式與 Dante 網路之間進行音訊傳輸。
    *   **與 ConMon 的關係：** DVS 和 Dante Via 在運行時，都會在本地電腦上提供一個 ConMon 服務介面。我們的應用程式通常會連接到這個本地 ConMon 服務 (即 `localhost`)，以控制本地的 DVS/Via 實例，或透過它作為代理與網路上的其他 Dante 設備通訊。

## 5. 硬體平台可行性評估 (給韌體工程師)

目前手上的板子，能否走這條路徑，關鍵在於其內部運行的 Dante 韌體。

*   **核心問題：** 該板子是否運行 Audinate 的 Dante 韌體？如果是，該韌體是否提供了可供客製化開發的 ConMon 介面？
*   **韌體可編程性：**
    *   Dante 韌體通常會暴露一個 ConMon 介面。問題在於，這個介面是否允許我們在韌體層面添加自訂邏輯來：
        *   監聽並識別非標準的「供應商 ID」。
        *   解析自訂訊息的「指令 ID」、「訊息類型」和「酬載」。
        *   執行自訂的動作。
        *   發送自訂的 ConMon 回覆訊息。
    *   如果板子是基於 Audinate 的 Dante 模組 (如 Ultimo、Brooklyn 等) 開發的，那麼其韌體通常會有一定的可擴展性，但具體程度需要查閱相關的韌體開發文件或諮詢 Audinate。

## 6. 替代方案：Routing API (`dr_devices`)

您提到了是否可以使用 Routing API (`dr_devices`) 來與設備通訊。

*   **Routing API 的用途：** Dante Routing API (`dr_devices`) 主要用於管理 Dante 網路中的音訊路由配置。這包括：
    *   查詢設備的音訊通道 (TX/RX Channels)。
    *   建立或刪除音訊訂閱 (Subscriptions)。
    *   設定通道名稱。
    *   查詢設備的音訊相關屬性 (如延遲、取樣率等)。
    *   它處理的是音訊數據流的「連接」和「屬性」。

*   **不適用於自訂資料傳輸：** Routing API **不是**為傳輸任意自訂資料包或通用命令而設計的。它沒有提供像 ConMon 供應商特定訊息那樣的通用酬載機制。雖然您可以透過查詢設備的某些屬性來間接確認一些狀態，但它無法用於發送像「執行動作 X」這樣的自訂指令。

*   **結論：** 對於傳送自訂資料或命令，**ConMon 供應商特定訊息是正確且預期的途徑。** Routing API 不適合此目的。

## 7. 總結與後續步驟

目前，C++ 應用程式已具備發送自訂 ConMon 供應商特定訊息的能力。要實現可靠的雙向通訊和測試確認，需要設備韌體的協同開發。

**for firmware：**

1.  **評估可行性：** 請確認板子上的 Dante 韌體是否支援處理自訂 ConMon 供應商特定訊息。
2.  **實現接收與解析：** 如果可行，請在韌體中實現對我們定義的「供應商 ID」、「指令 ID」、「訊息類型」和「酬載」的接收和解析邏輯。
3.  **定義並實現回覆機制：** 為了雙向測試和確認，請定義一個回覆訊息的格式 (可以是標準 ConMon 狀態訊息或另一個自訂供應商訊息)，並在韌體中實現發送該回覆的邏輯。
